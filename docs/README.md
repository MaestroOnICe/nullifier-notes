# Avoiding Double Spending with Nullifiers - research project

The goal of this small research project was to "*Implement a nullifier for a DApp where the double spending problem would arise otherwise.*"

To do so we implemented a small MVP for a "One-time note sharing" DApp. This problem can be solved with the help of blockchains or traditional with a centralized server approach. Both approaches will be compared and evaluated against each other.

### What is a nullifier?
"A cryptographic nullifier is a unique identifier generated by cryptographic algorithms to represent in an anonymous and privacy preserving manner the spending of a specific asset"

The nullifier is used to "prevent a user from doing an action twice while keeping them anonymous."[[1]](#1)

The simplest nullifier generation is a hash of a specific asset such as:
```bash
hash(text)
```
where the hash could be SHA and the text a String or something else. What we initially used is a simple has of the note and the current unix time. This is okay and naive but has some security implications later on.
```javascript
const hash = web3.utils.sha3(note + Date.now());
```
0x5baf10211f6fb43b79d1827c1d5edda50589b4862ac394d3fd9b48dfd6e64c8c
## DApp architecture
**Step 1:**
Alice creates a Note in the DApp, the note is encrypted with the nullifier. Both the encrypted note and the nullifier are than committed to the smart contract.

```mermaid
sequenceDiagram
    Actor Client
    participant DApp
    participant SmartContract
    
    Client->>DApp: Enter note
    DApp->>DApp: Hash note to create nullifier
    DApp->>DApp: Encrypt note with nullifier
    
    DApp->>SmartContract: Send encrypted note and nullifier
    SmartContract->>SmartContract: Check if nullifier has been used
    alt has been used
        SmartContract->>DApp: Notify that the nullifier has been used
        DApp->>Client: Notify that the nullifier has been used
    else has not been used
        SmartContract->>SmartContract: Store note identified by nullifier
        SmartContract->>DApp: Notify that the note has been stored
        DApp->>Client: Notify that the note has been stored
    end

```

The respective function in the smart contract is:
```solidity
function storeNote(bytes32 nullifier, bytes memory encryptedNote) public {
    require(!usedNullifiers[nullifier], "Nullifier already used");
    notes[nullifier] = encryptedNote;
    emit NoteStored(nullifier);
}
```
The encrypted note is saved in a mapping, identified by the nullifier. Crucial for preventing double spending or redeeming the note twice is the check if the nullifier was marked as used. The chance of a nullifier collision e.g. a collision in the hash function is almost zero.

**Step 2:**
Alice has to "somehow" communicate the nullifier to Bob
```mermaid
graph LR
    Alice((Alice))
    Bob((Bob))
    Alice -->|send nullifier| Bob
```
**Step3:**
Bob uses the nullifier to redeem the note an decrypt it.
```mermaid
sequenceDiagram
    Actor Client
    participant DApp
    participant SmartContract
    
    Client->>DApp: Enter nullifier
    
    DApp->>SmartContract: Send nullifier
    SmartContract->>SmartContract: Check if nullifier has been used
    alt has been used
        SmartContract->>DApp: Notify that the nullifier has been used
        DApp->>Client: Notify that the nullifier has been used
    else has not been used
        SmartContract->>SmartContract: Retrieve note identified by nullifier
        SmartContract->>SmartContract: Mark nullifier as used
        SmartContract->>DApp: Return encrypted note
        DApp->>Client: Return encrypted note
        Client->>Client: Decrypt note with nullifier
    end

```
Below is the function in the smart contract responsible for retrieving the note. Very important is the check if the nullifier has been used before. 

```solidity
function retrieveNote(bytes32 nullifier) public returns (bytes memory) {
    require(!usedNullifiers[nullifier], "Note already read");
    bytes memory note = notes[nullifier];
    require(note.length > 0, "Note does not exist");
    
    usedNullifiers[nullifier] = true;
    // potentially delete the note
    // delete notes[nullifier];
    emit NoteRetrieved(nullifier, note);
    return note;
}
```

### So all good? Not quite
The nullifier and the encrypted note are revealed to all users when the note is retrieved. Therefore is is very simple for everybody who knows the cipher to decrypt the note.

**Proof:**
![chain_explorer1.png](/docs/assets/chain_explorer1.png)

In this block we find the committed nullifier: 

*0x02c323de21e228452893b47307c541aaf9e4b1e046d1e87a7a8dcae234ec8d32bd0fa741*

and we find the encrypted data:

*0x553246736447566b58312f4f50654b31356a2f41622b626e616b67566e58783770534646614550397131323732344a2f6e557137336e344c38386174632b3361*

we then use AES to decrypt the message. We then get the note. Therefore this method is not secure!

## DApp architecture v2
Therefore we propose a altered version of the original DApp design. We use a [key derivation function](https://en.wikipedia.org/wiki/Key_derivation_function) or short KDF. When a note is created we create a secret on the client side. It can be extended into a 1. nullifier and 2. a secret key for encryption. The secret key is only used locally to encrypt and decrypt the note. The nullifier is shared in the smart contract and is used to prevent double spending.

The changed design can be seen below:
```mermaid
sequenceDiagram
    Actor Client
    participant DApp
    participant SmartContract
    
    Client->>DApp: Enter note
    DApp->>DApp: Generate secret
    DApp->>DApp: Derive secret key (SK) and the nullifier
    DApp->>DApp: Encrypt the note with SK

    DApp->>SmartContract: Send encrypted note and nullifier
```
With this design the encryption key can only be known used when the secret is known and is not saved on the blockchain.

Analog to **Step 2** above the secret is then shared or somehow transferred to Bob.

The retrieve part if this design then involves splitting the secret locally in the key SK and the nullifier. Using the nullifier to get the note and than decrypting it.

This can be found in the DApp as *Version 2* in the header.

### Okay we fixed all problems, right? No
For those who work with blockchains more frequent the problem will be obvious. We save the save the encrypted note in the smart contract and prevent *double reading* with the nullifier. But as the blockchain is a append only ledger, we can not erase the encrypted note send to the contract in the associated transaction. Meaning the person, which knows the transaction hash were the note was saved in the contract can read it again and again. If the deciphering is known. But we should just assume it is. 


## Traditional architecture
Here we have traditional design for the same functionality. Compared to **version 2** of the decentralized approach this service has to be trusted to mark notes as read. There is no publicly available smart contract to audit the onetime use of the note. The notes are encrypted with the nullifier as a key. The nullifier is available for the service so the notes could be read. This could be mitigated by also using a secret and a KDF to create nullifier and secret key.

```mermaid
sequenceDiagram
    Actor Sender
    participant WebApp
    participant Backend
    participant Database
    Actor Receiver

    Sender->>WebApp: Create note
    WebApp->>WebApp: Create nullifier and encrypt note with it
    WebApp->>Backend: Send encrypted note and nullifier
    Backend->>Database: Store encrypted note with nullifier
    Database->>Backend: Confirm storage
    Backend->>WebApp: Return success
    WebApp->>Sender: Return success

    Note over Sender,Receiver: Sender shares nullifier with Receiver securely

    Receiver->>WebApp: Enter nullifier
    WebApp->>Backend: Request note with nullifier
    Backend->>Database: Query note by nullifier
    Database->>Backend: Return encrypted note if exists
    Backend->>Backend: Verify note hasn't been read
    alt Note exists and unread
        Backend->>Database: Mark note as read and schedule for deletion
        Backend->>WebApp: Return encrypted note
        WebApp->>WebApp: Decrypt note with nullifier
        WebApp->>Receiver: Display decrypted note
    else Note doesn't exist or already read
        Backend->>WebApp: Return error
        WebApp->>Receiver: Display error message
    end
    Note over Database: Scheduled task periodically removes read notes
```

## References
<a id="1">[1]</a> Remco Bloemen, Nullifiers, 2024, https://2Ï€.com/22/nullifiers/